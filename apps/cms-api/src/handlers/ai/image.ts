/**
 * Generate header image using multiple providers (Gemini, OpenAI DALL-E)
 */
import type {
  GenerateImageRequest,
  GenerateImageResponse,
} from '@blog/cms-types';
import { generateId, generateImageId } from '@blog/utils';
import { Hono } from 'hono';
import type { Env } from '../../index';
import { internalError, validationError } from '../../lib/errors';
import { getImageUrl } from '../../lib/image-url';
import {
  ALL_IMAGE_MODELS,
  DEFAULT_IMAGE_MODEL,
  getImageProvider,
  HEADER_IMAGE_CONFIG,
} from './_shared';

export const imageHandler = new Hono<{ Bindings: Env }>();

interface GeneratedImage {
  data: Uint8Array;
  mimeType: string;
}

/**
 * Generate image using Gemini API
 */
async function generateWithGemini(
  apiKey: string,
  model: string,
  prompt: string
): Promise<GeneratedImage> {
  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': apiKey,
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [{ text: prompt }],
          },
        ],
        generationConfig: {
          responseModalities: ['IMAGE'],
        },
      }),
    }
  );

  if (!response.ok) {
    const errorText = await response.text();
    console.error('Gemini API error:', errorText);
    internalError('Failed to generate image with Gemini');
  }

  const data = await response.json<{
    candidates: Array<{
      content: {
        parts: Array<{
          inlineData?: { mimeType: string; data: string };
          text?: string;
        }>;
      };
    }>;
  }>();

  if (!data.candidates || data.candidates.length === 0) {
    internalError('No image generated by Gemini');
  }

  const parts = data.candidates[0].content.parts;
  const imagePart = parts.find((p) => p.inlineData);

  if (!imagePart?.inlineData) {
    internalError('No image data in Gemini response');
  }

  const imageData = imagePart.inlineData.data;
  const mimeType = imagePart.inlineData.mimeType || 'image/png';
  const binaryData = Uint8Array.from(atob(imageData), (c) => c.charCodeAt(0));

  return { data: binaryData, mimeType };
}

/**
 * Generate image using OpenAI DALL-E API
 */
async function generateWithOpenAI(
  apiKey: string,
  model: string,
  prompt: string
): Promise<GeneratedImage> {
  const response = await fetch('https://api.openai.com/v1/images/generations', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model,
      prompt,
      n: 1,
      size: model === 'dall-e-3' ? '1792x1024' : '1024x1024',
      response_format: 'b64_json',
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('OpenAI API error:', errorText);
    internalError('Failed to generate image with OpenAI');
  }

  const data = await response.json<{
    data: Array<{
      b64_json?: string;
      url?: string;
    }>;
  }>();

  if (!data.data || data.data.length === 0) {
    internalError('No image generated by OpenAI');
  }

  const imageData = data.data[0].b64_json;
  if (!imageData) {
    internalError('No image data in OpenAI response');
  }

  const binaryData = Uint8Array.from(atob(imageData), (c) => c.charCodeAt(0));
  return { data: binaryData, mimeType: 'image/png' };
}

imageHandler.post('/', async (c) => {
  const body = await c.req.json<GenerateImageRequest>();
  const { prompt, title, model = DEFAULT_IMAGE_MODEL } = body;

  if (!prompt) {
    validationError('Invalid input', { prompt: 'Required' });
  }

  // Validate model
  if (!ALL_IMAGE_MODELS[model as keyof typeof ALL_IMAGE_MODELS]) {
    validationError('Invalid model', {
      model: `Must be one of: ${Object.keys(ALL_IMAGE_MODELS).join(', ')}`,
    });
  }

  // Detect provider
  const provider = getImageProvider(model);
  if (!provider) {
    validationError('Invalid model', { model: 'Unknown provider' });
  }

  // Check API key
  const apiKey =
    provider === 'gemini' ? c.env.GEMINI_API_KEY : c.env.OPENAI_API_KEY;
  if (!apiKey) {
    internalError(
      `${provider === 'gemini' ? 'Gemini' : 'OpenAI'} API key not configured`
    );
  }

  // Build 3-layer prompt: system instructions + article content + user prompt
  const promptParts = [
    // Layer 1: System instructions for header image specifications
    HEADER_IMAGE_CONFIG.systemPrompt,
    '',
    // Layer 2: Article content (title)
    title ? `Article title: "${title}"` : null,
    // Layer 3: User's custom prompt
    prompt ? `Additional context: ${prompt}` : null,
  ].filter(Boolean);

  const imagePrompt = promptParts.join('\n');

  try {
    // Generate image based on provider
    const generated =
      provider === 'gemini'
        ? await generateWithGemini(apiKey, model, imagePrompt)
        : await generateWithOpenAI(apiKey, model, imagePrompt);

    // Upload to R2
    const id = generateId();
    const imageId = generateImageId(); // UUIDv4 for unpredictable URL path
    const ext = generated.mimeType === 'image/jpeg' ? 'jpg' : 'png';
    const filename = `${imageId}.${ext}`;
    const r2Key = `i/${filename}`;

    await c.env.R2_BUCKET.put(r2Key, generated.data, {
      httpMetadata: {
        contentType: generated.mimeType,
        cacheControl: 'public, max-age=31536000, immutable',
      },
    });

    // Save metadata to D1
    await c.env.DB.prepare(
      `INSERT INTO images (id, filename, original_filename, r2_key, mime_type, size_bytes, alt_text)
       VALUES (?, ?, ?, ?, ?, ?, ?)`
    )
      .bind(
        id,
        filename,
        `ai-generated-${provider}-${filename}`,
        r2Key,
        generated.mimeType,
        generated.data.length,
        prompt
      )
      .run();

    const publicUrl = getImageUrl(c.env, r2Key);

    const result: GenerateImageResponse = {
      id,
      url: publicUrl,
    };

    return c.json(result, 201);
  } catch (error) {
    console.error('Error generating image:', error);
    if (error instanceof Error && error.message.includes('API key')) {
      throw error;
    }
    internalError('Failed to generate image');
  }
});
